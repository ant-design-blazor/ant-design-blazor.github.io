{
  "Order": 5,
  "Title": "路径式属性访问",
  "Html": "<p>提供 <code>PropertyAccessHelper</code> 以实现通过属性路径字符串来访问对象的属性及其后代属性。</p>\n<h2>支持的操作</h2>\n<h3>1. 访问后代属性</h3>\n<p>例：<code>&quot;A.B.C&quot;</code>。</p>\n<h3>2. 数组模式索引，以及实现了 <code>Count</code> 属性和 <code>get_Item(int) (即 this[int]</code> 方法的 <code>类似 List 的</code> 类型</h3>\n<p>例：<code>&quot;A.B[1].C&quot;</code>。</p>\n<h3>3. 字典模式索引，以及实现了 <code>ContainsKey</code> 方法和 <code>get_Item (即 this[key])</code> 方法的 <code>类似 Dictionary 的</code> 类型。</h3>\n<p>例：<code>&quot;A.B[\\&quot;test\\&quot;].C&quot;</code>。</p>\n<h3>4. 数组、字典嵌套</h3>\n<p>例：<code>&quot;A.B[\\&quot;test\\&quot;][3].C&quot;</code>，<code>&quot;A.B[1][5].C&quot;</code>，<code>&quot;A.B[1][\\&quot;user id\\&quot;].C&quot;</code>。</p>\n<h3>5. 非空模式和可空模式</h3>\n<h4>5.1. 非空模式</h4>\n<p><span style=\"font-weight: bold;\">⚠注意：非空模式下需要开发者保证属性路径上的属性不为null，如果包含数组模式或字典模式，还需要保证索引对象必须存在，否则访问不存在的对象的属性时会抛出异常。</span></p>\n<p>当结果数据类型是值类型且不是Nullable时(如int)，会生成直接访问表达式，如果属性路径中存在Nullable类型，会不做null检查直接访问。</p>\n<p>如：访问属性<code>A.B.C</code> 时，其中 <code>B</code> 是 <code>Nullable&lt;MyStruct&gt;</code>，会生成类似 <code>A.B!.Value.C</code> 的表达式。</p>\n<p>对于数组或字典，会直接访问，如：访问数组对象属性 <code>A.B[i].C</code> 时，不会检查 <code>B.Count &gt; i &amp;&amp; i &gt; 0</code> 。访问字典对象属性 <code>A.D[&quot;my data&quot;].C</code> 时，不会检查 <code>D.ContainsKey(&quot;my data&quot;)</code>。</p>\n<h4>5.2. 可空模式</h4>\n<p><span style=\"font-weight: bold;\">可空模式下不需要保证数据不为null，也不用保证数组模式或字典模式必定有值，访问到不存在对象的属性时会返回null。</span></p>\n<p>当结果数据类型是Nullable值类型或class时(如int?, string)，会生成条件表达式，如果属性路径中存在Nullable或class类型，会先检查非null再访问，遇到null对象会返回null。</p>\n<p>如：访问属性 <code>A.B.C</code> 时，其中 <code>B</code> 是 <code>Nullable&lt;MyStruct&gt;</code>，会生成类似 <code>A.B.HasValue ? A.B.Value.C : null</code> 的表达式。</p>\n<p>对于数组或字典，会先检查再访问，如：访问数组对象属性 <code>A.B[i].C</code> 时，会检查 <code>B.Count &gt; i &amp;&amp; i &gt; 0</code> , 结果是 <code>false</code> 时返回 <code>null</code> 。访问字典对象属性 <code>A.D[&quot;my data&quot;].C</code> 时，会检查 <code>D.ContainsKey(&quot;my data&quot;)</code>, 结果是 <code>false</code> 时返回 <code>null</code> 。</p>\n<h2>API</h2>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th style=\"text-align: left;\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BuildAccessPropertyLambdaExpression</td>\n<td style=\"text-align: left;\">创建非空属性访问Lambda表达式, 调用Compile()后即可使用</td>\n</tr>\n<tr>\n<td>BuildAccessNullablePropertyLambdaExpression</td>\n<td style=\"text-align: left;\">创建可空属性访问Lambda表达式, 调用Compile()后即可使用</td>\n</tr>\n<tr>\n<td>AccessProperty</td>\n<td style=\"text-align: left;\">生成非空属性访问链表达式, 需要串联ToXXX方法创建最终表达式</td>\n</tr>\n<tr>\n<td>AccessNullableProperty</td>\n<td style=\"text-align: left;\">生成可空属性访问链表达式，需要串联ToXXX方法创建最终表达式</td>\n</tr>\n<tr>\n<td>AccessPropertyDefaultIfNull</td>\n<td style=\"text-align: left;\">生成DefaultIfNull属性表达式，当属性访问结果是null时，使用传入的默认值，需要串联ToXXX方法创建最终表达式</td>\n</tr>\n<tr>\n<td>ToDelegate</td>\n<td style=\"text-align: left;\">从AccessXXX方法创建委托方法</td>\n</tr>\n<tr>\n<td>ToLambdaExpression</td>\n<td style=\"text-align: left;\">从AccessXXX方法创建Lambda表达式</td>\n</tr>\n<tr>\n<td>ToFuncExpression</td>\n<td style=\"text-align: left;\">从AccessXXX方法创建Func&lt;,&gt;委托方法</td>\n</tr>\n</tbody>\n</table>\n"
}